## To do 
- 정처기 part1_3
# 소프트웨어 설계
## 화면 설계
- `UI라는 단어가 들어가면 무조건 사용자 중심으로 모든 것을 판단하고 생각해야 문제풀이에 어려움이 없을 것이다.`

### **유용성 평가**
- 뜻 : 사용자 입장에서 얼마나 유용한지
- 실행(기능) : 불필요, 중복, 불편, 어려운
- 결과(평가) : 즉각적이지 않은 피드백, 결과 이해, 파악이 어려움
### **UI 상세 설계**
#### UI 시나리오 문서의 개요
- UI 설계서를 바탕으로 실제 설계 및 구현을 위해 모든 화면에 대한 자세한 설계를 진행
- 시나리오를 작성해야 함
- 사용자 인터페이스의 기능 구조, 대표화면, 화면 간 상호작용의 흐름, 다양한 상황에서의 예외 처리 등을 문서로 정리

#### UI 시나리오 문서 작성 원칙
- 개발자가 전체 UI 기능과 작동 방식을 이해할 수 있도록 구체적으로 작성
- UI 요소와 인터랙션을 일반 규칙으로 정의
- 인터랙션의 흐름을 정의하고 인터랙션의 순서, 분기, 조건, 반복 등을 명시
- 예외 상황에 대비한 다양한 케이스를 정의
#### UI 시나리오 문서 작성을 위한 일반 규칙
- 주요 키의 위치와 기능
    - 모든 화면에 공통적으로 배치되는 주요 키의 위치와 기능을 설명
    - 여러 화면 간 일관성 보장
- 공통 UI 요소
    - UI 요소를 언제 어떤 형태로 사용할 지 정의
    - 사용자의 조작에 대한 반응하는지에 대한 흐름을 설명
- 기본 스크린 레이아웃
    - 모든 화면에 공통적으로 나타나는 요소들에 대한 위치와 속성을 정의
- 기본 인터랙션 규칙
    - 터치 제스처 등에 공통적으로 사용되는 조작 방법과 화면 전환 효과등을 기술
- 공통 단위 태스크 흐름
    - 많은 기능들에 공통적으로 사용되는 삭제, 검색, 매너 모드 상태 등에 대한 인터랙션 흐름 설명
- 케이스 문서
    - 다양한 상황에서 공통적으로 적용되는 시스템의 동작을 정의한 문서
#### UI 시나리오 문서의 요건
- 완전성 : 누락되지 않도록 상세히 기술
- 일관성 : 서비스의 목표, 요구사항, UI 스타일이 모두 일관성을 유지해야 함
- 이해성 : 누구나 쉽게 이해할 수 있도록 설명
- 가독성 : 표준화된 템플릿을 활용하여 읽기 쉽도록 해야 함
- 수정 용이성 : 시나리오의 수정, 개선이 쉬워야 함
- 추적 용이성 : 변경 사항이 언제 어떻게 왜 발생했는지 쉽게 추적할 수 있어야 함
### **HCI/UX/감성공학**
#### HCI(Human Computer Interaction or Interface)
- 사람이 시스템을 보다 편리하고 안전하게 사용할 수 있도록 개발, 연구하는 학문
- 최종 목표는 시스템을 사용하는데 있어 최적의 사용자 경험(UX)을 만드는 것
#### UX(User eXperience)
- 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험
#### 감성공학
- 제품이나 작업환경을 사용자의 감성에 맞도록 설계 제작하는 기술







# 소프트웨어 설계
## 애플리케이션 설계
### **소프트웨어 아키텍처**
#### 소프트웨어 아키텍처의 설계
- 소프트웨어의 골격이 되는 기본 구조
- 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
- 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈간의 인터페이스 등을 결정
#### 모듈화
- 소프트웨어의 성능을 향상하거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
- 모듈의 크기는 개수와 반비례
- 모듈의 개수와 통합비용은 비례
#### 추상화
- 문제의 전체를 설계 후 세분화하여 구체화하는 과정
- 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어 여러가지 요인들을 테스트할 수 있음
- 최소 비용으로 실제 상황에 대처할 수 있고 시스템의 구조 및 구성을 대략적으로 파악할 수 있음
- 추상화 유형:
    - 과정 추상화 : 전반적인 흐름만 파악
    - 데이터 추상화 : 데이터의 세부사항을 정의하지 않고 구조를 대표할 수 있는 표현으로 대체
    - 제어 추상화 : 이벤트 발생의 세부사항은 정의하지 않고 구조를 대표할 수 있는 표현으로 대체
#### 단계적 분해
- 문제를 상위 중요 개념으로부터 하위의 개념으로 구체화하는 분할 기법
- 추상화의 반복으로 세분화
#### 정보 은닉
- 한 모듈 내부에 포함된 정보들을 감추어 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 다른 모듈과 커뮤니케이션을 항 때는 필요한 정보만 인터페이스를 통해 주고받음
- 모듈을 독립적으로 수행하기 때문에 다른 모듈에 영향을 주지 않아 수정, 시험, 유지보수가 용이
#### 소프트웨어 아키텍처의 품질 속성
- 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지하고 보장할 수 있게 설계되었는지를 확인하기 위해 품질 요소들을 구체화시켜 놓은 것
1. 시스템 측면
- 성능 : 요청과 같은 이벤트 발생 시 적절하고 빠르게 처리
- 보안 : 허용된 접근에는 적절한 서비스를, 허용되지 않은 접근은 차단
- 가용성 : 장애없이 정상적으로 서비스 제공
- 기능성 : 요구한 기능을 만족스럽게 구현
- 사용성 : 소프트웨어를 사용하는데 있어 명확하고 편리하게 구현
- 변경 용이성 : 다른 하드웨어나 플랫폼에도 동작할 수 있도록 구현
- 확장성 : 시스템을 확장 시 효과적으로 활용할 수 있도록 구현
- 기타 속성 : 텍스트 용이성, 배치성, 안정성 등
2. 비즈니스 측면
- 시장 적시성 : 정해진 시간에 맞춰 프로그램 출시
- 비용과 혜택 : 개발 비용을 투자하여 유연성이 높은 아키텍처를 만들지 결정
- 예상 시스템 수명 : 시스템을 얼마나 오랫동안 사용할지 고려. 수명이 길 경우 변경 용이성, 확장성을 중요하게 고려해야 함
- 기타 속성 : 목표 시장, 공개 일정, 기존 시스템과 통함 등
3. 아키텍처 측면
- 개념적 무결성 : 전체 시스템과 시스템을 이루는 구성요소들 간 일관성 유지
- 정확성, 완결성 : 요구사항을 위해 발생하는 제약사항들을 모두 충족
- 구축 가능성 : 모듈 단위로 구분된 시스템을 적절하게 분배하여 일정을 변경할 수 있도록 함
- 기타 속성 : 변경성, 시험성, 적응성, 일치성, 대체성 등
#### 소프트웨어 아키텍처의 설계 과정
1. 설계 목표 설정
- 시스템의 개발 방향을 명확히 하기 위해 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2. 시스템 타입 결정
- 시스템과 서브 시스템 타입 결정
- 설계목표를 고려하여 아키텍처 패턴 선택
3. 아키텍처 패턴 적용
- 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처 설계
4. 서브시스템 구체화
- 서브시스템의 기능 및 상호작용을 위한 동작과 인터페이스 정의
5. 결론
- 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지 등을 검토

### **아키텍처 패턴**
- `아키텍처 = 기본 구조`, `아키텍처 패턴 = 공식`
#### 아키텍처 패턴의 개요
- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 시스템의 구조를 구성하기 위한 기본적인 틀을 제공
- 서브시스템과 그 역할이 정의되어 있어 서브시스템 사이 관계와 규칙, 지침 등이 포함되어 있음
- 아키텍처 패턴의 장점
    - 개발 시간을 단축시킴
    - 고품질의 소프트웨어 생산 가능
    - 검증된 구조로 작업을 하여 안정적인 개발 가능
    - 시스템 구조를 이해하기 쉬워 개발에 참여하지 않아도 유지보수가 쉬움
#### 레이어 패턴
- 시스템을 계층으로 구분하여 구성
- 각각의 서브 시스템이 계층 구조를 이룸
- 상위계층은 하위 계층에 대한 서비스 제공자가 되고 하위 계층은 상위 계층의 클라이언트가 됨
- 마주보는 두 계층 사이에만 상호작용이 이루어짐
- 특정 계층만을 교체해 시스템을 개선하는 것이 가능
#### 클라이언트-서버 패턴
- 하나의 서버와 다수의 클라이언트로 구성
- 사용자는 클라이언트를 통해 서버에 요청하고 응답을 받아 사용자에게 제공
- 서버는 클라이언트의 요청에 대비해 항상 대기 상태 유지
- 요청을 위하여 동기화되는 경우를 제외하고는 서로 독립적임
#### 파이프-필터 패턴
- 데이터 스트림(데이터가 송수신되거나 처리되는 흐름) 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송
- 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이
- 필터 컴포넌트를 재배치하여 다양한 파이프라인 구축 가능
- 데이터 변환, 버퍼링, 동기화 등에 사용
#### 모델-뷰-컨트롤러 패턴
- 서브시스템을 3개의 부분으로 구조화
- 모델 : 서브시스템의 핵심 기능과 데이터 보관
- 뷰 : 사용자에게 정보 표시
- 컨트롤러 : 사용자로부터 받은 입력 처리
- 각 부분은 별도로 분리되어 있어 서로 영향을 받지 않고 독립적인 개발 작업 수행
- 여러개의 뷰를 만들 수 있어 한 개의 모델에 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합
#### 마스터-슬레이브 패턴
- 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후 슬레이브 컴포넌트에서 병렬처리된 결과물을 다시 돌려받는 방식
- 도중에 몇 개의 슬레이브가 고장이 나도 업무 처리엔 문제가 없다
#### 브로커 패턴
- 클라이언트가 원하는 서비스의 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 서버를 연결해줌
#### 피어-투-피어 패턴
- 서버와 클라이언트가 역할을 서로 바꿀 수 있음
- 토렌트나 웹하드의 P2P
- 2가지의 일을 병렬로 수행하는 멀티 스레딩이 특징임
#### 이벤트-버스 패턴
- 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
#### 블랙보드 패턴 
- 많은 컴포넌트들이 공유데이터를 관리하는 블랙보드에 접근해 검색을 통해 데이터를 찾는 형식
- 음성인식, 차량식별, 신호해석등의 기술에서 사용
#### 인터프리터 패턴
- 프로그램 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성

### **객체지향**
#### 객체지향의 개요
- 현실세계의 개체를 기계의 부품처럼 하나의 객체(Object)로 만들어 소프트웨어를 개발할 때 객체를 조립하여 작성할 수 있는 기법
- 구조적 기법의 문제점을 해결하기 위해 사용
- 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있어 유지보수가 쉬움
- 복잡한 구조를 단계적이고 계층적이게 표현
- 멀티미디어 데이터 및 병렬 처리 지원
- 구성 요소 : `객체, 클래스, 캡슐화, 상속, 다형성`
#### 객체
- 데이터와 데이터를 처리하는 함수를 묶어 캡슐화한 하나의 소프트웨어 모듈
- 데이터 : 객체가 가지고 있는 정보
- 함수 : 객체가 수행하는 기능으로 데이터를 처리하는 알고리즘
- 객체의 특성
    - 객체는 독립적으로 식별 가능한 이름을 가지고 있음
    - 객체의 상태는 시간에 따라 변함
    - 객체 간의 상호 연관성에 의해 관계 형성
    - 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며 객체는 행위의 특징을 나타낼 수 있음
    - 객체는 일정한 기억 장소를 가지고 있음
#### 클래스
- 공통된 속성과 연산을 갖는 객체의 집합으로 객체의 일반적인 타입을 의미
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 인스턴스 : 클래스에 속한 각각의 객체
- 인스턴스화 : 클래스로부터 새로운 객체를 생성하는 것
- 슈퍼 클래스 : 특정 클래스의 부모(상위) 클래스
- 서브 클래스 : 특정 클래스의 자식(하위) 클래스
#### 캡슐화
- 데이터와 함수를 하나로 묶은 것
- 인터페이스를 제외한 세부 내용이 은폐되어 외부에서 접근이 제한적이기 때문에 외부에서 변경하기 어려움
#### 상속
- 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
- 하위 클래스는 부모 클래스의 모든 속성과 연산을 다시 정의하지 않고 사용할 수 있음
- 하위 클래스는 상속받은 속성 외에 새로운 속성과 연산을 첨가하여 사용할 수 있음
- 객체와 클래스의 재사용을 높이는 중요한 개념
- 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 상속받는 것
#### 다형성
- 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 클래스가 가지고 있는 고유한 특성으로 응답할 수 있는 능력
- 객체지향의 오버로딩의 개념
- 
    ```
    클래스는 상속을 통해 여러 기능을 확장할 수 있고 거기에서 생성된 인스턴스 역시 많은 기능을 가지고 있다.
    그런데 이 인스턴스에 기능의 제한을 걸어서 특정 기능만 수행할 수 있다면 
    일일히 그 기능만 수행하는 객체들을 따로 생성할 필요 없이 하나의 통합 객체로 여러가지 일을 수행할 수 있게 되는 개념이 다형성임
    ```
### **모듈**
#### 모듈의 개요
- 모듈화를 통해 분리된 시스템의 각 기능들
- 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용
- 단독으로 컴파일 가능하며 재사용 할 수 있음
- 각 모듈의 기능이 서로 독립적이고 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함
- 독립성이 높을수록 모듈을 수정해도 다른 모듈에 영향이 없어 오류가 발생해도 쉽게 해결 가능
- 모듈의 독립성을 높이기 위해서는 결합도는 약하게, 응집도는 강하게 해야함
#### 결합도
- 모듈 간에 상호 의존도 또는 모듈 사이의 연관 관계
- 결합도와 품질은 반비례 관계
- 결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움
- 결합도의 종류 (결합도가 강한->약한 순서대로 나열했음)
1. 내용 결합도 (content)
- `내부 기능과 데이터 직접 참조`
- 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
- 다른 모듈의 내부로 제어가 이동하는 경우도 포함
2. 공유(공통) 결합도 (common)
- `여러 모듈들이 공통으로 데이터 사용`
- 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
- 공통 데이터 영역의 내용을 변경 시 이를 사용하는 모든 모듈에 영향을 미쳐 모듈의 독립성을 약하게 만듦
3. 외부 결합도 (external)
- `다른 모듈이 내부 데이터 접근`
- 모듈에서 선언한 데이터를 외부의 다른모듈에서 참조할 때의 결합도
- 참조되는 데이터의 범위를 각 모듈에서 제한
4. 제어 결합도 (control)
- `다른 모듈에서 흐름을 제어`
- 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도
- 권리 전도 현상 : 하위 모듈이 상위 모듈에게 처리 명령을 내리는 현상
5. 스탬프 결합도 (stamp)
- `자료구조로 구성 (다른 모듈이 영향을 받음)`
- 모듈 간의 인터페이스가 배열이나 레코드 등의 자료구조가 전달할 때의 결합도
- 두 모듈이 동일한 자료 구조를 조회
6. 자료 결합도(data)
- `데이터로 구성`
- 모듈간의 인터페이스가 자료 요소로만 구성될 때의 결합도
- 모듈은 호출 시 매개변수나 인수로 데이터를 넘겨주고 처리 결과를 반환

#### 응집도
- 정보 은닉 개념을 확장한 것으로 모듈의 내부 요소들의 서로 관련되어 있는 정도
- 모듈이 독립적인 기능으로 정의되어 있는 정도
- 응집도와 품질은 비례 관계
- 응집도의 종류 (응집도가 강한->약한 순서대로 나열했음)
1. 기능적 응집도 (functional)
- `단일문제-단일기능`
- 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
2. 순차적 응집도 (sequential)
- `이전 모듈 출력 -> 다음 모듈 입력`
- 모듈 내 하나의 활동으로부터 나온 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
3. 통신적 응집도 (communication)
- `동일 입출력으로 서로 다른 기능 수행`
- 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
4. 절차적 응집도 (procedural)
- `다수의 기능이 순차적으로 진행`
- 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
5. 시간적 응집도 (temporal)
- `특정 시간대에 처리되는 기능 모음`
- 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
6. 논리적 응집도 (logical)
- `유사한 기능 모음`
- 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
7. 우연적 응집도 (coincidental)
- `관련없는 요소로 구성`
#### 팬 인/아웃
- 팬 인 : 호출하는 모듈의 수 (화살표가 들어오는)
- 팬 아웃 : 호출되는 모듈의 수 (화살표가 나가는)
### **공통모듈**
#### 공통 모듈의 개요
- 여러 프로그램에서 공통적으로 사용할 수 있는 모듈
- 자주 사용되는 계산식이나 매번 필요한 사용자 인증 같은 기능들이 공통 모듈로 구성될 수 있음
#### 공통모듈의 명세 기법
|기법|설명|
|---|---|
|정확성(correctness)|필요성|
|명확성(clarity)|비중의적(한가지 의미로 해석되도록)|
|완전성(completeness)|필요한 모든 것|
|일관성(consistency)|충돌방지|
|추적성(traceability)|출처, 관계 파악|

#### 재사용
- 비용과 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 개발에 사용하기 적합하도록 최적화 시키는 작업
- 재사용되는 대상은 외부 모듈과의 결합도는 낮고 응집도는 높아야 함
#### 효과적인 모듈 설계 방안
- `결합도(down) + 응집도(up) = 독립성(up) = 재사용(up)`
- `복잡도(down) + 중복성(down) + 입출력(down) = 품질(up)`
- 결합도는 줄이고 응집도는 높여 모듈의 독립성과 재사용성을 높임
- 하나의 입구와 하나의 출구를 가져야 함
- 중복되지 않으면서 하나의 입출력을 가지도록 설계해야 함
### **코드**
#### 코드의 개요
- 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고 특정 자료의 추출을 쉽게 하기 위해 사용하는 기호
- 코드의 기능 : 식별, 분류, 배열
#### 코드의 종류
- 순차 코드 : 일정 기준에 따라 최초의 자료부터 일련번호를 부여하는 방법
    - 1, 2, 3 ...
- 블록 코드 : 대상 항목에서 공통적인 것들을 블록으로 구분하고 블록 내에 일련번호를 부여하는 방법
    - A학과 : 1001~1100, B학과 : 1101~1200 ...
- 10진 코드 : 대상 항목을 0~9까지 10진 분할하고 다시 각각에 대해 10진 분할을 필요한 만큼 반복하는 방법
    - 1317 : 1(국내도서) 3(소설) 1(고전문학) 7(독일소설)
- 그룹 분류 코드 : 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고 그룹 안에서 일련번호를 부여하는 방법
    - 1-04-002, 3-07-057 ...
- 연상 코드 : 항목의 명칭이나 약호와 관계있는 숫자, 문자, 기호를 이용하여 코드를 부여하는 방법
    - LG-OLED50 : LG 50인치 TV ...
- 표의 숫자 코드 : 항목의 성질(길이, 넓이, 부피 등)의 물리적인 수치를 그대로 코드에 적용시키는 방법
    - R 300-400-600 : R(박스색상) 300(가로) 400(세로) 600(길이)
- 합성 코드: 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 적용시키는 방법
#### 코드 부여 체계
- 코드(이름)만으로도 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식
- 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 함

### **디자인 패턴**
#### 디자인 패턴의 개요
- 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 개발 과정에 문제가 발생 시 새로 해결책을 구상하기보다는 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더욱 효율적임
- 재사용할 수 있는 기본형 코드들이 포함되어 있음
#### 생성 패턴
- `캡슐화, 유연성`
- 객체의 생성과 참조 과정을 샘플화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 크게 영향을 받지 않도록하여 프로그램의 유연성을 더해줌
##### 추상팩토리(Abstract Factory)
- `객체 생성코드가 상위 클래스에 존재. 하위(구체화) 클래스가 받아 씀`
- 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
##### 팩토리 메소드(Factory Method)
- `객체 생성코드를 하위 클래스에서 구체화. 생성 클래스는 인터페이스만 제공`
- 객체 생성을 하위 클래스에서 처리하도록 분리하여 캡슐화한 패턴
##### 빌더(Builder)
- `분리 된 인스턴스를 조합하여 객체 생성`
##### 프로토타입(Prototype)
- `원본 복제, 비용 저렴`
- 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
##### 싱글톤(Singleton)
- `클래스 내 인스턴스가 하나뿐임을 보장. 동시 참조 불가능`
- 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할 수는 없음

#### 구조 패턴
- `복잡한 구조의 시스템 개발에 필요`
- 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
##### 어댑터(Adapter)
- `일치하지 않는 인터페이스 변환`
- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
##### 브리지(Bridge)
- `추상층(기능)과 구현층(구체화)을 분리하여 독립적 확장`
- 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴
##### 컴포지트(Composite)
- `트리구조 구성. 단일과 복합 객체 구분없이 다룸`
- 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
##### 데코레이터(Decorator) 
- `기능 추가위해 다른 객체를 덧붙임`
- 객체간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
##### 퍼싸드(Facade)
- `서브 클래스들의 통합 인터페이스를 제공(*wrapper객체*)하는 상위 클래스 구성`
- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구상함으로써 서브 클래스의 기능을 간편하게 사용할 수 있도록 하는 패턴
##### 플라이웨이트(Flyweight)
- `다수의 유사 객체 생성이 필요할 때 최대한 공유해서 사용(메모리절약)`
- 인스턴스가 필요할 때마다 생성하는 것이 아닌 공유해서 사용함으로써 메모리를 절약하는 패턴
##### 프록시(Proxy)
- `접근이 어려운 객체에 접근할 수 있도록 인터페이스 역할 수행`
#### 행위 패턴
- `상호작용, 책임 분배`
- 클래스나 객체들이 서로 작용하는 방법이나 책임 분배 방법을 정의한 패턴
##### 책임 연쇄(Chain of Responsibility)
- `둘 이상의 객체가 연결(chain)되어 책임이 차례로 넘어감`
- 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
##### 커맨드(Command)
- `명령어 캡슐화(추상과 구체). 로그에 기록`
- 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
##### 인터프리터(Interpreter)
- `문법 표현 정의. 맞춤법 검사`
- 언어에 문법 표현을 정의하는 패턴
##### 반복자(Iterator)
- `접근이 잦은 객체는 동일한 인터페이스 사용하도록. 순차접근`
- 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
##### 중재자(Mediator)
- `복잡한 상호작용 캡슐화`
- 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
##### 메멘토(Memento)
- `특정 시점의 상태 객체화. 되돌리기`
- 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
##### 옵서버(Observer)
- `이벤트 발행과 구독. 상태 변화 전달`
- 한 객체의 상태가 변화하면 객체에 상속되어있는 다를 객체들에게 변화된 상태를 전달하는 패턴
    - 카톡의 읽음 표시
##### 상태(State)
- `상태에 따라 동작을 다르게`
- 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용하는 패턴
    - 카톡의 알림
##### 전략(Strategy)
- `동일 계열 알고리즘 상호 교환. 독립적 사용`
- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
##### 템플릿 메소드(Template Method)
- `상위에서 인터페이스 정의. 하위에서 구체화(유지보수)`
- 상위 클래스에서 골격을 정의하고 하위 클래스에서 처리를 구체화하는 구조의 패턴
- 생성 패턴의 팩토리 메소드와 같은 개념
##### 방문자(Visitor)
- `처리 기능을 별도의 클래스로 구성`
- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴