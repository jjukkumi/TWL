# To do
- 정처기 2과목 반 이상

# 소프트웨어 개발
## 통합구현
### **단위 모듈 구현**
#### 단위 모듈
- 모듈의 개수 = 기능의 개수
- 완벽히 하나의 기능을 구현하기 때문에 독립적 컴파일 가능
- 구현 순서 : `단위 기능 명세서 작성 - 입출력 기능 구현 - 알고리즘 구현`
#### 단위 기능 명세서 작성
- `추상화-구조화-캡슐화`
- 단위 기능을 명세화한 문서
- 복잡한 시스템을 단순하게 구현하기 위한 **추상화** 작업이 필요
- 대형 시스템을 분해하여 단위 기능별로 구분하고 각 기능들을 계층적으로 구성하는 **구조화** 과정을 거침
#### 입출력 기능 구현
- 단위 기능 명세서에서 정의한 데이터 형식에 따라 입출력 기능을 위한 알고리즘 및 데이터 구현
- 모듈 간 데이터 연동 또는 통신을 위해 구현
- IPC(Inter Process Communication) : 모듈 간 통신을 구현하기 위해 사용되는 인터페이스 집합
    - 공유 메모리(Shared Memory) 
        - `공유 가능한 메모리 구성`
        - 다수의 프로세스가 공유 가능한 메모리를 구성하여 통신 수행
    - 소켓(Socket) 
        - `소켓을 이용하여 내트워크 경유`
        - 네트워크 소켓을 이용하여 네트워크를 경유하는 통신 수행
    - 세마포어(Semaphores)
        - `공유 자원에 대한 접근 제어`
        - 공유 자원에 대한 접근 제어를 통해 통신 수행
    - 파이프(Pipes & named Pipes)
        - `선입선출 형태로 구성`
        - 선입선출의 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신 수행
    - 메시지 큐잉(Message Queueing)
        - `메시지 전달`
        - 메시지가 발생하면 이를 전달하는 형태로 통신 수행
#### 알고리즘 구현
- 입출력 데이터를 바탕으로 단위 기능별 요구사항들을 구현 가능 언어를 이용해 모듈로 구현
### **단위 모듈 테스트**
#### 단위 모듈 테스트의 개요
- 모듈이 정해진 기능을 정확히 수행하는지 검증
- 테스트에 필요한 환경, 데이터 준비
- 시스템 수준의 오류 발견 불가능
#### 테스트 기법
- 화이트박스 : 소스코드의 논리적인 경로 테스트
- 블랙박스 : 해당 기능의 작동 여부 테스트
#### 테스트 케이스
- 구현된 소프트웨어가 요구사항을 정확히 준수했는지 확인하기 위한 테스트 항목에 대한 명세서로 명세 기반 테스트의 설계 산출물에 해당
- 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스를 만듦
#### 테스트 케이스의 구성 요소
- 식별자(Identifier): 식별자, 일련번호
- 테스트 항목(Test Item) : 테스트 대상
- 입력 명세(Input Specification) : 입력 데이터, 조건
- 출력 명세(Output Specification) : 예상 결과
- 환경 설정(Environment Needs) : 필요 HW/SW
- 특수 절차 요구(Special Procedure Requirement) : 요구 절차
- 의존성 기술(Inter-case Dependencies) : 케이스간 의존성
#### 테스트 프로세스
- 테스트를 위해 수행하는 작업이 테스트의 목적과 조건을 달성할 수 있도록 도와주는 과정
1. 계획/제어
- `계획 수립`
- 목표 달성 위한 계획 수립 / 진행되도록 제어
2. 분석/설계
- `시나리오 및 케이스 작성`
- 목표 구체화하여 테스트 시나리오와 테스트 케이스 작성
3. 구현/실현
- `테스트 프로시저 작성, 테스트 수행`
- 테스트 케이스들을 조합하여 테스트 프로시저에 명세
- 모듈 환경에 적합한 단위 테스트 도구를 이용하여 테스트 수행
4. 평가
- `평가 기록`
- 테스트가 잘 수행되었는지 평가하고 기록
5. 완료
- `산출물 저장`
- 이후 테스트를 위해 수행 과정과 산출물을 기록 및 저장
### **개발 지원 도구**
#### 통합 개발 환경(IDE)
- 
    ```
    에디터, 디버거 등 통합
    코드 자동 생성
    추가 기능 다운로드
    코드, 오류 시각화
    다양한 서비스 연동
    컴파일 가능
    ```

- 개발에 필요한 편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공
- Eclipse, Visual Studio, Xcode, Android Studio 등

#### 빌드 도구
- 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물
- 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업을 수행
- Ant : 자바 프로젝트의 공식적인 빌드도구(표준없음, XML)
- Maven : Ant의 대안으로 의존성을 설정하여 라이브러리 관리(의존성)
- Gradle : 안드로이드 스튜디오의 공식 빌드 도구(의존성, groovy)

#### 협업 도구
- 개발에 참여하는 사람들이 서로 다른 작업 환경에서 프로젝트를 수행할 수 있도록 도와주는 도구
- 협업 소프트웨어, 그룹웨어라고도 함
- 도구에 익숙치 않으면 오히려 방해가 됨
- 프로젝트 및 일정 관리 : 구글 캘린더, 분더리스트, 트렐, 지라, 플로우 등
- 정보 공유 및 커뮤니케이션 : 슬랙, 잔디, 태스크 월드 등
- 디자인 : 스케치, 제플린 등
- 아이디어 공유 : 에버노트 등
- API 문서화 : 스웨거 등
- Git 웹 호스팅 서비스 : 깃허브 등

## 제품 소프트웨어 패키징
### **소프트웨어 패키징**
#### 소프트웨어 패키징의 개요
- 실행 파일을 묶어 배포용 설치 파일을 만듦
- 사용자 중심으로 진행
- 모듈화 하여 일반 배포 형태로 패키징
- 지속적으로 관리될 수 있는 형태로 배포해야함
#### 패키징 고려사항
- 사용자의 운영체제, CPU, 메모리 등에 필요한 최소 환경 정의
- UI는 시각적인 자료와 함께 매뉴얼과 일치시켜 패키징
- 소프트웨어는 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
#### 패키징 작업 순서
1. 코드 완성
2. 기능 식별
3. 모듈화
4. 빌드
5. 사용자 환경 정의
6. 패키징 및 적용, 테스트
7. 패키징 개선
8. 배포(릴리즈)

### **릴리즈 노트**
#### 릴리즈 노트의 개요
- 개발 과정에서 정의된 릴리즈 정보를 고객에게 공유하기 위한 문서
- 소프트웨어의 버전 관리 및 릴리즈 정보를 체계적으로 관리
- 소프트웨어 초기 배포나 출시 후 개선사항을 적용한 추가 배포 시 제공
- 릴리즈 노트에 포함되는 내용 : 전체 기능, 서비스, 개선사항
#### 릴리즈 노트 초기 버전 작성 시 고려사항
- 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성
- 신규 코드, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한 이력 정보들도 작성
#### 릴리즈 노트 추가 버전 작성 시 고려사항
- 테스트 과정에서 베타 버전이 출시되거나 긴급 버그 수정, 업그레이드, 사용자 요청 등의 특수한 상황의 경우 작성
- 긴급 버그 수정 시 수정하는 경우 릴리즈 버전을 출시하고 그 번호를 포함한 모든 내용을 수정된 내용을 담음
- 요구사항에 의해 추가 혹은 수정된 경우 자체 기능 향상과는 다른 별도의 릴리즈 버전으로 출시하고 작성
#### 릴리즈 노트 작성 순서
1. 모듈 식별
2. 릴리즈 정보 확인
3. 릴리즈 노트 개요 작성
4. 영향도 체크
5. 정식 릴리즈 노트 작성
6. 추가 개선 항목 식별
### **디지털 저작권 관리**
#### 저작권의 개요
- 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한
- 컴퓨터 프로그램처럼 복제하기 쉬운 저작물에 대해 저작권을 보호하는 방법을 저작권 보호 기술이라 함
#### 디지털 저작권 관리(Digital Right Management)의 개요
- 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 생성, 유통, 이용까지 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술
- 크기가 작은 경우 사용자가 콘텐츠를 요청하는 시점에 실시간 패키징 수행
- 크기가 큰 경우 미리 패키징을 수행 후 배포
- 종량제 방식을 적용한 소프트웨어의 경우 서비스의 실제 사용량을 측정하여 이용한 만큼 이용 부과
#### 디지털 저작권 관리의 흐름도
- 클리어링 하우스 : 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따를 결제 관리 등 수행
- 콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자
- 패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
- 콘텐츠 분배자 : 암호화된 콘텐츠를 유통
- 콘텐츠 소비자 : 콘텐츠를 구매해서 사용
- DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
- 보안 컨테이너 : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
#### 디지털 저작권 관리의 기술 요소
- 암호화
- 키 관리
- 암호화 파일 생성
- 식별 기술
- 저작권 표현
- 정책 관리
- 크랙 방지
- 인증
### **소프트웨어 설치 매뉴얼 작성**
#### 소프트웨어 설치 매뉴얼의 개요
- 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 문서
- 설치 시작부터 완료까지의 과정을 순서대로 설명
- 사용자 기준 기술, 전체 과정 포함
#### 서문
- 문서 이력, 설치 매뉴얼의 주석, 설치 도구의 구성, 설치 환경 체크 항목 기술
- 설치 매뉴얼의 주석 : 주의사항과 참고사항 기술
- 설치 환경 체크 항목 : 사용자 환경, 응용 프로그램, 업그레이드 버전, 백업 폴더 확인
#### 기본 사항
- 소프트웨어 개요, 설치 관련 파일, 설치 아이콘, 프로그램 삭제, 관련 추가 정보 설명

#### 설치 매뉴얼 작성
- 사용자가 설치 과정을 이해하기 쉽게 설치 화면을 누락 없이 캡처하여 순서대로 설명
- 설치화면 및 UI: 각 과정의 이미지 첨부
- 설치 이상 메시지: 오류설명, 주의사항
- 설치 완료 및 결과 : 결과화면 공지
- FAQ : 문제발생시 해결방안
- 설치 시 점검사항 : 환경/권한 점검
- 네트워크 환경 및 보안
- 고객 지원 방법: 웹사이트, 연락처
- 보증 : 준수사항 및 라이선스 정보
#### 설치 매뉴얼 작성 순서
1. 기능 식별
2. UI 분류
3. 설치/백업 파일 확인
4. 삭제 절차 확인
5. 이상 케이스 확인
6. 최종 매뉴얼 작성

### **소프트웨어 사용자 매뉴얼 작성**
#### 소프트웨어 사용자 매뉴얼의 개요
- 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 기록한 문서
- 사용자 기준 기술, 전체 과정 포함
#### 서문
- 문서 이력, 사용자 매뉴얼의 주석, 기록 보관 내용 기술
- 기록 보관 내용 : 소프트웨어를 사용하면서 필요한 기술 지원이나 추가 정보를 얻기 위한 소프트웨어 등록 정보 기술

#### 기본 사항 
- 소프트웨어 개요, 사용 환경, 관리, 모델 버전 별 특징, 기능 및 인터페이스의 특징, 구동 환경 설명
#### 사용자 매뉴얼 작성
- 사용자가 사용방법을 이해하기 쉽도록 작성
- 사용자 화면 및 UI : 각 과정의 이미지 첨부
- 주요 기능 분류 : 기능에 대한 사용법
- 응용 프로그램 및 설정 : 설정 및 기본값
- 장치 연동 : 연동되는 장치
- 프로파일 안내 : 필수 구동 환경
- 네트워크 환경 및 보안
- 고객 지원 방법 : 웹사이트, 연락처
- 보증 : 준수사항 및 라이선스 정보
#### 사용자 매뉴얼 작성 순서
1. 기능 식별
2. 사용자 화면 분류
3. 사용자 환경 파일 확인
4. 초기화 절차 확인
5. 이상 케이스 확인
6. 최종 매뉴얼 작성

### **소프트웨어 버전 등록**
#### 소프트웨어 패키징 형상 관리
- 형상 관리는 소프트웨어의 변경 사항을 관리하기 위한 활동
- 유지보수 단계를 포함한 개발의 모든 단계에서 진행
#### 형상 관리의 중요성
- 지속적으로 변경사항을 체계적으로 관리 및 추적할 수 있음
- 발견된 버그나 수정 사항을 추적
- 개발의 진행정도 확인
- 오류 및 변경 방지

#### 형상 관리 기능
##### 형상 식별
- 대상에 이름과 관리 번호를 부여하고 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
##### 버전 제어
- 소프트웨어 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고 특정 절차와 도구를 결합하는 작업
##### 형상 관리/통제
- 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 하는 작업
- Base Line을 넘지 않도록 통제
##### 형상 감사
- 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
- Base Line을 넘었는지 체크
##### 형상 기록 
- 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업
#### 소프트웨어 버전 등록 관련 주요 용어
- 저장소(Repository) : 형상에 대한 정보들이 저장되어 있는 곳
- 가져오기 : 아무것도 없는 저장소에 처음으로 파일 복사
- 체크아웃 : 저장소에서 소스 파일, 버전 관리를 위한 파일을 받아옴
- 체크인 : 체크아웃으로 받아온 파일을 수정 후 저장소에 새로운 버전으로 갱신
- 커밋 : 체크인 수행 시 이전에 갱신된 내용이 있는 경우 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신
- 동기화(update) : 저장소에 있는 최신 버전을 동기화

### **소프트웨어 버전 관리 도구**
#### 공유 폴더 방식
- 개발자가 공유 폴더를 생성하여 개발된 파일을 저장해두면 다른 개발자가 자신의 PC로 파일을 복사하여 테스트를 진행하고 문제가 발생하면 해당 개발자에게 수정을 의뢰하는 형태
- 한명의 개발자만 버전 관리의 책임을 맡게됨
#### 클라이언트/서버 방식(SVN)
- 버전 관리 자료가 서버에 저장되어 관리
- 서버의 자료를 자신의 PC로 복사하여 작업 후(checkout) 변경 내용을 서버에 반영
- 기존의 개발작업 외에 추가적인 작업이 필요한 경우 별도의 디렉토리(branches)에서 작업을 진행 후 주 디렉토리(trunk)와 병합(merge)하는 방식으로 진행
- 새롭게 생성 된 파일들은 별도로 서버에 미리 등록(add)해야 서버에 반영(commit)할 수 있음
- 반영 전에는 항상 서버와 데이터를 동기화(update)하여 최신 상태에서 진행
- 공유 폴더와 달리 여러 대의 클라이언트에서 개발 및 테스팅이 가능
- 모든 버전 관리는 서버에서 수행 -> 서버에 문제가 생기면 더 이상의 작업이 불가능해짐 -> 분산저장소 방식을 통해 보완
#### 분산 저장소 방식(Git)
- 버전 관리를 하나의 원격 저장소와 분산된 PC의 로컬 저장소에 함께 저장되어 관리 -> 한쪽에 문제가 생기거나 네트워크에 문제가 생겨도 작업 가능
- 로컬에서 실제 개발과 버전 관리를 진행하고 원격 저장소에 해당 내용을 반영
- 클라이언트/서버 방식과 달리 분산 저장소 방식은 로컬에서 버전관리를 할 수 있기 때문에, 반영의 위치가 서버가 아닌 로컬임을 유의!
- 로컬에 저장소를 생성(init)하고, 서버와 연결(remote add)
- 서버에서 전체 내용을 가져옴(clone)
- 이후에는 일부 변경된 내용만 가져옴(fetch)
- 필요에 따라 다른 서버의 내용을 가져올 수도 있음(fork)
- 추가적인 작업이 필요할 경우 별도의 영역을 생성(branch) -> 해당 영역으로 이동(checkout)해 작업 -> 병합(merge)
- 개발이 완료되면 완료된 파일을 스테이징 영역에 추가(add)
- 내용이 안전하게 추가되었다면 로컬에 반영(commit)
### **빌드 자동화 도구**
- 소스 코드를 컴파일한 후 여러 개의 모듈로 묶어 실행 파일로 만드는 과정을 포함하여 배포를 자동화하는 도구
#### Jenkins
- **Java**기반의 오픈소스
- 서블릿 컨테이너에서 실행되는 서버 기반 도구
- **형상 관리 도구와 연동** 가능
- **Web GUI** 제공으로 사용이 편리
- 여러 대의 컴퓨터를 이용한 **분산 빌드**나 테스트 가능
#### Gradle
- **Groovy**기반의 오픈소스 형태의 자동화 도구
- **안드로이드** 앱 개발 환경에 사용
- Groovy를 사용해 만든 **DSL을 스크립트 언어로** 사용
- Java, C/C++, Python등의 언어도 빌드 가능
- 실행할 처리 명령들을 모아 태스크로 만든 후 **태스크 단위로** 실행
- 이전의 태스크를 재사용하거나 다른 시스템의 태스크를 공유하여(**캐시 기능 지원**) 빌드의 속도 향상 가능

---
